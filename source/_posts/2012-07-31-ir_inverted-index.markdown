date: 2012-07-31 09:05:27+00:00
title: '[信息检索IR]01.倒排索引(Inverted Index)'
tag: [信息检索, 机器学习]

---

假设要查询文本中是否含有某个单词，第一个蹦入我们脑海中的想法一定就是把这个文本从头到尾通读一次，知道读到这个单词为止。
这就是最简单的一种遍历方式。虽然简单，但是在面对许多文本的时候，效率就会显得相当低下。

假设现在有如下4个文本：

_doc1: the day the night_
_ doc2: the day_
_ doc3: the night_
_ doc4: the midnight_

需要查询究竟是哪篇文章含有单词"midnight"（query:midnight）

I.

这时如果按顺序遍历的话，共需要访问10次(依次读取比对the, day, the, night, the, day, the, night, the, midnight)才能得到查询的结果doc4。
那么除了最基本的按照顺序检索之外，是否还具有别的更有效率的方法呢？

<!--more-->

II.
答案是肯定的，之前我们是以文档集中的**文档**为检索单位进行检索，现在换个角度，以单词组成的词典中的**单词**为检索的单位进行检索。这个思想背后的想法我觉得应该是这样的——再厚的书或者其他文字资料最终也都是来自于一本小小的字典里单词的排列组合而形成的，所以以字典作为切入点将会大大提高检索的效率。

为了实现这种检索方式，首先我们要对原来的文档集进行一些基本的处理来构建词典，而词典中的注释则是包含有这个单词的文档号，如下:
doc1中发现新单词the, day, night存入词典中，并给这几个单词添加相应的文档号1做注释；
doc2中无新单词，给the, day这两个单词添加对应的文档号2作为注释；
doc3中无新单词，给the, night两个单词添加对应的文档号3作为注释；
doc4中给the添加对应的文档号4作为注释，发现新单词midnight存入词典中，添加4作为其注释。
完成词典的构建工作，此时我们得到的词典应该是这样的：


> **the** - 含有此单词的文档ID: 1, 2, 3, 4
**day** - 含有此单词的文档ID: 1, 2
**night** - 含有此单词的文档ID: 1, 3
**midnight** - 含有此单词的文档ID: 4


以这种方式组织词典，接下来在应对查询"midnight"的时候，我们只需要从字典里找到这个单词，其对应的注释部分便是查询的结果。在已有词典的情况下，这次查询的开销不过就是4次访问。

倒排索引
这第二种组织文档、单词的方式就被称为构建**倒排索引**(**_Inverted Index_**)

这种将单词作为检索的依据，并将文档记录置于后端作为尾巴；与传统的以文档记录作为检索依据，以单词作为查询内容的方式相反，所以这种检索结构称为倒排记录表(posting)。

![](/img/2012-07-31-ir_inverted-index-01.jpg)

以下是一些术语：
而以这种方式组成的词典就被称为倒排记录表/倒排表(postring list/inverted list),所有的倒排表一并成为全体倒排记录表(postings)。
![](/img/2012-07-31-ir_inverted-index-02.jpg)

采用倒排记录表来处理文档集的好处不言自明，如果采用传统的方式，每次查询需要花费的时间复杂度均为O(n)，其中n为文档集的总长度，而若是采用倒排记录表的方式，只有第一次构建词典时需要花费O(n)，之后的每次处理的时间复杂度均为O(m),m为词典的长度，在面对大量的文档数据时，m << n。
