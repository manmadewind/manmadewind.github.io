date: 2012-08-01 12:06:25+00:00
title: '[实践笔记][C#]的笔记搜集养成'
tags: [C#, note]

---

## DataTable & XML
DataTable/DataSet和XML文件之间的互操作
有一个DataTable(table),需要写成XML文件：

	table.WriteXmlSchema(fileName1);
	table.ReadXml(fileName2);

读取时：

	table.ReadXmlSchema(fileName1);
	table.ReadXml(fileName2);

## byte[] & string
byte[] string之间的一种更简单的转换方式,不用像传统的方式一样还要动用到字符编码。

1.byte[] -> string

	Convert.ToBase64String(byte[] ...);
	
2.string -> byte[]

	Convert.FromBase64String(string ...);

<!--more-->


普通的方法：
string类型转成byte[]：

	byte[] byteArray = System.Text.Encoding.Default.GetBytes ( str );
	
反过来，byte[]转成string：

	string str = System.Text.Encoding.Default.GetString ( byteArray );

其它编码方式的，如System.Text.UTF8Encoding，System.Text.UnicodeEncoding class等；例如：
string类型转成ASCII byte[]：（"01" 转成 byte[] = new byte[]{ 0x30, 0x31}）
byte[] byteArray = System.Text.Encoding.ASCII.GetBytes ( str );
ASCII byte[] 转成string：（byte[] = new byte[]{ 0x30, 0x31} 转成 "01"）
string str = System.Text.Encoding.ASCII.GetString ( byteArray );
 
## 嵌入资源
运用工程中的文件，并不能直接将文件拖入Resources文件夹中，而是需要先展开Properties文件夹，双击Resources.resx,再用鼠标点击“添加资源”，用这种方式才可以将文件以比较正统的方式加入工程中并且能被该工程所应用。
接下来就可以在代码中使用Properties.Resources_._**_对应的文件名_** 来访问资源

## 有关ComboBox
使ComboBox中显示一套值，而后台可以读出对应的实际的值。比如我们在ComboBox中显示的是用户名，而和它对应的用户ID可以直接读取到。

    
    
        DataTable table = new DataTable();
        table.Columns.Add("userName", typeof(string));
        table.Columns.Add("userID",   typeof(int));
    
        comboBox_Instance.DataSource    = table;//绑定comboBox和数据源DataTable
        comboBox_Instance.DisplayMember = "userName";//前台显示文本
        comboBox_Instance.ValueMember   = "userID";//后台值
    


这样comboBox里的内容就被绑定好了，从今以后我们可以选择是要选取它的显示值或是对应的后台值

    
    
        string selectedText  = comboBox_Instance.SelectedText;//选定的用户名
        string selectedValue = comboBox_Instance.SelectedValue;//选定文本值对应的ID
    


p.s:要使Combobox的值只能为从下拉框里选而不能随意被用户修改，只要将combobox的属性DropDownStyle的值选为DropDownList便可

[ASP.NET]动态更换CSS文件
方法1：

    
    
        string cssFilePath = "...";//CSS文件路径
        HtmlLink objLink1  = new HtmlLink();
    
        objLink1.Attributes["href"] = String.Format(cssFile, themeName);
        objLink1.Attributes["rel"]  = "stylesheet";
        objLink1.Attributes["type"] = "text/css";
    
        this.Page.Header.Controls.Add(objLink1);
    


方法2：
在前台页面上放置一个有ID的，并且runat="server"的link，这样的link能被后台服务端访问到。这样也可以实现动态地修改这个link的href属性。
举例：
前台：

    
    
        <link href="#" type="text/css" id="link_Css" rel="stylesheet" runat="server">
    


后台：

    
    
        string cssFilePath = "...";//CSS文件路径
        this.link_Css.Attributes["href"] = cssFilePath;


## [ASP.NET]服务端嵌入javascript代码

(1)直接用Response输出脚本（不推荐）

    
    
        Rsponse.Write("<script type="text/javascript">(window.alert('登录名或者密码错误，请重新登录！'))</script>");
    


但这种方法不稳妥,特别是放在page_load()中的时候,经常得不到结果.

(2)使用内置的ClientScriptManager输出脚本

    
    string scriptCommand_RefreshPage = "window.location.reload();";            
        string script = string.Format("<script type="text/javascript" language="javascript">{0}</script>", scriptCommand_RefreshPage);
        ClientScriptManager jsManager = Page.ClientScript;
        jsManager.RegisterStartupScript(this.GetType(), "", script);


ClientScriptManager里还有几种很有用的方法.如果碰到比较麻烦的问题最好尽量还是用它来解决.

[ASP.NET]TextBox设置ReadOnly后会碰到一些问题
当把TextBox的ReadOnly属性设置为true时，Postback之后将会无法直接读取它的值。
解决方法有两种
(1) 使用Request.Form[this.textBox_Instance.UniqueID]来代替this.textBox_Instance.Text取值。
(2) 使用TextBox_Instance.Attributes.Add(“readonly”, “readonly”);来设置TextBox为只读而不是直接设定TextBox的ReadOnly=true;


> 
参考:
http://www.dotblogs.com.tw/petedotnet/archive/2009/07/09/9280.aspx
http://west-wind.com/weblog/posts/3939.aspx
http://www.codeproject.com/KB/aspnet/Readonly.aspx
http://www.g9th.com/blog/post/2006/12/Readonly-property-of-Textbox-in-ASPNET.aspx




## 关于友元(InternalsVisibleTo)
使得当前工程被标记为internal的方法/类可以被其他工程所调用，即确立一个友元工程。
只要在当前工程的Properties/AssembleyInfo.cs中添加如下代码：

    
    
    [assembly: System.Runtime.CompilerServices.InternalsVisibleTo("友元的程序集名称")]
    



通常，具有 internal 作用域（在 C# 中）和 friend 作用域（在 Visual Basic 中）的类型和成员仅在定义它们的程序集中可见。 InternalsVisibleToAttribute 特性使它们对指定的程序集中的类型也可见，该程序集已知为好友程序集。
该特性在程序集级别应用。这意味着它可以包含在源代码文件的开头，或者它可以包含在 Visual Studio 项目中的 AssemblyInfo 文件中。您可以使用该特性指定一单个友元程序集，该程序集可以访问当前程序集的内部类型和成员。可通过两种方式确定多个友元程序集。它们可以显示为单个程序集级属性，如下面的示例所示。
